# JavaScript ES6 Ejercicios

En estos ejercicios se trabajar谩 con las nuevas caracter铆sticas de JavaScript ES6.<br>
Se requiere refactorizar algunos c贸digos ES5 a ES6.

## Ejercicio 1

1. Refactoriza la funci贸n `filterNumbers()` para usar sintaxis `arrow function`.

```js
function filterNumbers(arr, largerThan) {
  return arr.filter(function (number) {
    return number > largerThan;
  });
}
```

2. Refactoriza la funci贸n `returnFirstTwoDrivers()` para usar sintaxis `arrow function`.

```js
function returnFirstTwoDrivers() {
  const drivers = ["Sally", "Bob", "Freddy", "Claudia"];
  return drivers.slice(0, 2);
}
```

## Ejercicio 2: Par谩metros por defecto

1.Refactoriza la funci贸n `add()` para usar la sintaxis de par谩metros por defecto.

```js
function add(a, b) {
  a = a || 1;
  b = b || 1;
  return a + b;
}
```


## Ejercicio 3: Map

1. Usando `map`crea un nuevo array que contenga la altura de las im谩genes. Asigna este array a la variable `heights`.

```js
var images = [
  { height: '34px', width: '39px' },
  { height: '54px', width: '19px' },
  { height: '83px', width: '75px' },
];
```


2. Usando `map` crea un nuevo array que contenga la `distance` / `time` de cada viaje. Asigna el nuevo array a la variable `speeds`.

```js	
var trips = [
  { distance: 34, time: 10 },
  { distance: 90, time: 50 },
  { distance: 59, time: 25 }
];
```

## Ejercicio 4: Filter


1. Filtra los n煤meros mayores a 50. Asigna el resultado a la variable `filteredNumbers`.

```js
var numbers = [15, 25, 35, 45, 55, 65, 75, 85, 95];
```

2. Filtra un array de usuarios, solo mostrando los usuario que tienen permisos de administrador. Asigna el resultado a la variable `admins`.

```js
var users = [
  { id: 1, admin: true },
  { id: 2, admin: false },
  { id: 3, admin: false },
  { id: 4, admin: true },
  { id: 5, admin: true },
];
```

## Ejercicio 5: Find

>  El m茅todo `find` devuelve el primer elemento que cumple con la condici贸n dada. Si no encuentra ning煤n elemento, devuelve `undefined`.

1. Encuentra el usuario que tiene un `username` igual a `'waldo'`. Asigna el resultado a la variable `user`, utilizando el m茅todo `find`.

```js
var users = [
  { username: 'waldo', name: 'Waldo' },
  { username: 'batman', name: 'Batman' },
  { username: 'joker', name: 'Joker' },
];
```

## Ejercicio 6: Reduce

>  La funci贸n `reduce` recibe dos par谩metros, una funci贸n y un valor inicial. La funci贸n recibe dos par谩metros, el acumulador y el valor actual.

Ejemplo de uso con arrow function:

```js
var numbers = [1, 2, 3, 4, 5];

//Ejemplo de uso de reduce con funci贸n con nombre
function sumFn1(acc, number) => {
  return acc + number;
};
var sum = numbers.reduce(sumFn1, 0);

//Ejemplo de uso de reduce con funci贸n an贸nima, y asignada a una variable
const sumFn2 = (acc, number) => {
  return acc + number;
};

var sum = numbers.reduce(sumFn2, 0);

//Ejemlo de uso de reduce con arrow function
var sum = numbers.reduce((acc, number) => {
  return acc + number;
}, 0);

console.log(sum); // 15
```

1. Usando `reduce` suma todas las distancias de los viajes. Asigna el resultado a la variable `totalDistance`. Usa preferiblemente la sintaxis de arrow function.

```js
var trips = [
  { distance: 34 },
  { distance: 90 },
  { distance: 59 },
];
```

2. Usando objetos como acumulador.<br>
   Usa `reduce` para crear un objeto que contenga la cantidad de objetos por tipo. El objeto resultante deber铆a ser similar a `{ sitting: 3, standing: 2 }`. El inicial valor del acumulador debe ser un objeto vac铆o `{ sitting: 0, standing: 0 }`.

```js	
const desks = [
  { type: 'sitting' },
  { type: 'standing' },
  { type: 'sitting' },
  { type: 'sitting' },
  { type: 'standing' }
];

var accInitialObject = { sitting: 0, standing: 0 };
var deskTypes = desks.reduce(function(total, desk) {
    // aplicar la l贸gica aqu铆
    
    return total
}, accInitialObject );
```	



## Ejercicio 7: Rest y spread operator

 Ayuda: [Spread Operator](https://playcode.io/javascript/spread-operator), [Rest Parameters](https://playcode.io/javascript/rest-parameters)

>  El operador spread se indica (...), permite expandir elementos. Por otro lado, el operador rest tambi茅n es indicado por (...), pero se utiliza para agrupar elementos.


1. Se dispone de un array con frutas, y se tiene otro array con otras frutas. Se requiere utilizando el operador spread, unir ambos arrays en uno solo.

Para resolver este ejercicio, se puede realizar de forma imperativa, de la siguiente forma:

```js	
//Forma imperativa, pero siempre se colaca al final del array
var todasLasFrutas = frutas.concat(otrasFrutas);
```
Ahora resuelve el ejercicio utilizando el operador spread.

```js
var frutas = ['manzana', 'pera', 'naranja'];

var otrasFrutas = ['banana', 'sand铆a', 'uva'];

var todasLasFrutas = // Utilizar el operador spread para unir ambos arrays

```

2. Ahora aplica lo anterior con objetos, se tienen 2 objetos con propiedades distintas, se requiere unir ambos objetos en uno solo.

```js
var persona = { nombre: 'Juan', edad: 25 };

var infoExtra = { ciudad: 'Lima', pais: 'Per煤' };

var personaCompleta = // Utilizar el operador spread para unir ambos objetos
```

3. Ahora vamos a utilizar el operador Spread, para copiar un objeto en otro, y modificar una propiedad.



```js
var persona = { nombre: 'Juan', edad: 25 };

var personaModificada = // Utilizar el operador spread para copiar el objeto persona, y modificar la propiedad edad
```

**Spread Operator en funciones**

Cuando se utiliza el operador spread en funciones, se le conoce como Rest Parameters, y se utiliza para agrupar elementos.

4. Se tiene una funci贸n que recibe 3 par谩metros, pero se requiere que reciba un solo par谩metro, y que este par谩metro sea un array con los 3 valores. Utiliza el operador Rest para agrupar los par谩metros en un solo array.

```js
function sumar(a, b, c) {
  return a + b + c;
}

var numeros = [1, 2, 3];

var resultado = sumar(numeros); // Debe devolver 6

//Cambia la funci贸n sumar para que reciba un solo par谩metro, y que este sea un array con los 3 o N valores
```


## Ejercicio 8: Destructuring

 Ayuda: [Destructuring](https://playcode.io/javascript/destructuring)

>  La destructuraci贸n es una forma de extraer valores de arrays u objetos y asignarlos a variables.

En este ejemplo se tiene un objeto con propiedades, y se requiere extraer las propiedades en variables.

```js
var persona = {
  nombre: 'Juan',
  edad: 25,
  ciudad: 'Lima'
};

var nombre = persona.nombre;
var edad = persona.edad;
var ciudad = persona.ciudad;
```

Tambi茅n se puede realizar la destructuraci贸n en la misma l铆nea.

```js
var { nombre, edad, ciudad } = persona;
```

El nombre de la variable debe coincidir con el nombre de la propiedad del objeto.


>  La destructuraci贸n tambi茅n se puede aplicar a arrays.

```js
var frutas = ['manzana', 'pera', 'naranja'];

var [fruta1, fruta2, fruta3] = frutas;
```

Y tambi茅n se puede aplicar sobre Argumentos de funciones, extrayendo solo los valores necesarios.

```js
//Complex object with multiple properties 
const person = {
  name: 'Juan',
  age: 25,
  city: 'Lima',
  country: 'Per煤'
};

//Destructuring the object in the function arguments

function printPerson({ name, age }) {
  console.log(`Name: ${name}, Age: ${age}`);
}
```

En este caso solo se extraen las propiedades name y age del objeto person, solo las que se necesitan


**Ejercicios**


1. Se tiene un objeto data con valores sobre Trading, se requiere extraer los valores en variables.
  

```js
var data = {
  nombre: 'Bitcoin',
  precio: 10000,
  volumen: 1000
};

//Extrae los valores del objeto data en variables en la misma l铆nea
```

2. Se tiene un array con 3 elementos de nombre de animales, se requiere extraer los valores en variables.

```js
var animales = ['perro', 'gato', 'loro'];

//Extrae los valores del array frutas en variables en la misma l铆nea
```

3. Se tiene un objeto json que provienen de una llamada externa (API), de los despegues de SpaceX. Se requiere solo extraer los valores de la propiedad `launches` en una variable.

```js
var json = {
  status: 'success',
  data: {
    launches: [
      { name: 'Falcon 1', date: '2006-03-24' },
      { name: 'Falcon 9', date: '2010-06-04' },
      { name: 'Falcon Heavy', date: '2018-02-06' }
    ]
  }
};

//Extrae los valores de la propiedad launches en una variable
```

4. Siguiendo el ejemplo anterior, se requiere imprimir el nombre del cohete y la fecha, utilizando destructuring.

```js
var json = {
  status: 'success',
  data: {
    launches: [
      { name: 'Falcon 1', date: '2006-03-24' },
      { name: 'Falcon 9', date: '2010-06-04' },
      { name: 'Falcon Heavy', date: '2018-02-06' }
    ]
  }
};

launches.forEach(function(launch) {
  console.log(`Rocket: ${launch.name}, Date: ${launch.date}`);
});
```

Utiliza destructuring para extraer los valores del objeto launch en la funci贸n forEach, para que quede de la siguiente forma:

```js
//Cambia XXX por lo requierido
launches.forEach(XXX) {
  console.log(`Rocket: ${name}, Date: ${date}`);
});
```


## Ejercicio 9: Template Linterals

 Ayuda: [Template Literal](https://playcode.io/javascript/template-literals)

>  Los template literals son una forma de concatenar strings de forma m谩s sencilla.


1. Refactoriza el siguiente c贸digo para usar string template literals.

```js
const savedFile = {
  extension: "jpg",
  name: "repost",
  size: 14040,
};

function fileSummary(file) {
  return (
    "The file" + file.name + "." + file.extension + "is of size" + file.size
  );
}
```

2. Refactoriza el siguiente c贸digo para usar string template literals.

```js
let name = 'world';
let greeting = 'Hello + name + '!';  //Cambiar esta l铆nea por template literals

console.log(greeting);
```

3. Refactoriza el siguiente c贸digo para usar string template literals.

```js
let product = { name: 'Smartphone', price: 1000 };

let message = 'The price of the ' + product.name + ' is $' + product.price + '.'; //Cambiar esta l铆nea por template literals
```	

## Ejercicio 10: Promesas

 Ayuda: [Promesas](https://www.youtube.com/watch?v=DiaGSWK0pv8), [Promesas 2](https://www.youtube.com/watch?v=rKK1q7nFt7M)

**Callback**

Antes de las promesas, las operaciones as铆ncronas se manejaban con callbacks, lo que generaba el problema de los callbacks hell, que es la anidaci贸n de callbacks, lo que dificulta la lectura y mantenimiento del c贸digo.

Para simular la asincron铆a, se utiliza la funci贸n `setTimeout`, que simula que la petici贸n tarda 2 segundos en responder.

```js	
function getUsers(callback) {
  console.log('--- Inicio de la petici贸n ----');

  setTimeout(() => {
    
    const users = [
      { id: 1, name: 'Juan' },
      { id: 2, name: 'Pedro' },
      { id: 3, name: 'Mar铆a' }
    ];

    console.log(' ::: Petici贸n resuelta :::');
    callback(users);  //llamamos a la funci贸n de vuelta (callback)
  }, 2000);

  console.log(' --- Fin de la petici贸n ---');
}
```

Ahora para llamara a la funci贸n getUsers, se hace de la siguiente forma:

```js
getUsers((users) => {
  console.log(users);
});
```

El problema de los callballs, es el llamado `callback hell`, que es la anidaci贸n de callbacks, lo que dificulta la lectura y mantenimiento del c贸digo.

```js
getUsers((users) => {
  //Esto a su vez puede llamar a otra funci贸n con otro callback
  getRoles(users, (roles) => {
    // Y su vez a otra funci贸n con otro callback
    getPermissions(roles, (permissions) => {
      console.log(permissions);
    });
    //Y as铆 sucesivamente
    //Esto provoca el callback hell, un anidamiento de llamadas a callback que dificulta la lectura y mantenimiento del c贸digo
  });
});
```

**Promesas**

>  Las promesas son objetos que representan la terminaci贸n o el fracaso de una operaci贸n as铆ncrona.


Siguiente el ejemplo anterior, vamos a refactorizar el c贸digo para utilizar promesas.

```js
function getUsers() {
  
  console.log('--- Inicio de la petici贸n ----');

  return new Promise((resolve, reject) => {
    setTimeout(() => {
      
      const users = [
        { id: 1, name: 'Juan' },
        { id: 2, name: 'Pedro' },
        { id: 3, name: 'Mar铆a' }
      ];

      console.log(' ::: Petici贸n resuelta :::');
      resolve(users);

    }, 2000);
  });
  
  console.log(' --- Fin de la petici贸n ---');
}
```	

En el caso de las promesas, la funci贸n `resolve` es el equivalente al callback, y se llama cuando la operaci贸n as铆ncrona se ha completado.

Ahora para llamar a la funci贸n getUsers, se hace de la siguiente forma:

```js
getUsers()
  .then((users) => {
          console.log(users);
        })

  .catch((error) => {
          console.log(error);
        });
```

En la parte de `then` se recibe el resultado de la promesa, y en `catch` se recibe el error en caso de que la promesa falle.


**Encadena promesas**

En el caso de las promesas, se pueden encadenar, para evitar el callback hell.

```js
getUsers()
  .then((users) => {
    return getRoles(users);
  })
  .then((roles) => {
    return getPermissions(roles);
  })
  .then((permissions) => {
    console.log(permissions);
  })
  .catch((error) => {
    console.log(error);
  });
```
De esta forma se evita el callback hell, y se mantiene un c贸digo m谩s limpio y f谩cil de leer. En cuanto un error se produzca, se captura en el `catch`.


### Ejercicios

 1. Refactoriza la siguiente funci贸n para que retorne una promesa en lugar de usar un callback.
   
```js
function getData(callback) {
  setTimeout(() => {
    callback({ data: 'Here is some data' });
  }, 2000);
}
```

2. Crea una funci贸n que retorne una promesa que se resuelva despu茅s de 2 segundos y devuelva el texto "Hello, World!". Haz un ejemplo de uso de la funci贸n.

```js
//Crea la funci贸n que retorne una promesa
```

3. Crea una funci贸n que retorne una promesa que se rechace despu茅s de 2 segundos y devuelva el error "Something went wrong". Haz un ejemplo de uso de la funci贸n.

```js
//Crea la funci贸n que retorne una promesa
```


## Ejercicio 11: Async/Await

 Ayuda: [Async/Await](https://playcode.io/javascript/async-await)

>  Async/Await es una forma de trabajar con promesas de forma m谩s sencilla y legible, es como escribir c贸digo as铆ncrono de la misma forma que escribimos c贸digo s铆ncrono (la forma tradicional)

Siguiendo los ejemplos anteriores, vamos a refactorizar el c贸digo para utilizar async/await.

```js
async function getUsers() {
  
  console.log('--- Inicio de la petici贸n ----');

  //Ahora en lugar de retornar una promesa, se almacena en una variable, y se espera a que se resuelva
  const promise = new Promise((resolve, reject) => {
    setTimeout(() => {
      
      const users = [
        { id: 1, name: 'Juan' },
        { id: 2, name: 'Pedro' },
        { id: 3, name: 'Mar铆a' }
      ];

      console.log(' ::: Petici贸n resuelta :::');
      resolve(users);

    }, 2000);
  });

  const result = await promise;  //Espera a que la promesa se resuelva
  
  console.log(' --- Fin de la petici贸n ---');
}

//Llamada a la funci贸n getUsers usando async/await
const users = await getUsers();
console.log(users);
```

En caso de que la promesa falle, se puede capturar el error con un bloque `try/catch`.

```js
try {
  const users = await getUsers();  //Espera a que la promesa se resuelva

} catch (error) {
  console.log(error);
}
```

Como se puede comprobar con async/await, el c贸digo es m谩s limpio y f谩cil de leer, y se mantiene la misma estructura que el c贸digo s铆ncrono.

### Ejercicios

1. Refactoriza la siguiente funci贸n para que utilice async/await en lugar de promesas.

```js
function fetchData() {
  return new Promise((resolve, reject) => {
    setTimeout(() => resolve('Data fetched!'), 2000);
  });
}

fetchData().then(data => console.log(data));
```

```js	
//Refactoriza la funci贸n fetchData para que utilice async/await
```

2. Crea una funci贸n async que utilice await para esperar la resoluci贸n de una promesa que se resuelve despu茅s de 2 segundos y devuelve el texto "Hello, World!".

```js
//Crea la funci贸n async
```

3. Crea una funci贸n async que utilice await para esperar la resoluci贸n de una promesa que se rechaza despu茅s de 2 segundos y devuelve el error "Something went wrong".

```js
//Crea la funci贸n async
```

4. **Caso pr谩ctico RESUELTO**<br>
   Refactoriza la siguiente funci贸n para que utilice async/await en lugar de promesas.

```js
function getFirstUserData() {
  return fetch('/users.json')
    .then(response => response.json())
    .then(users => users[0])
    .then(user => fetch(`/users/${user.name}`))
    .then(userResponse => userResponse.json());
}

//Llamada a la funci贸n
getFirstUserData().then(data => console.log(data));

//Esta es pasando todo a async/await, pero no es muy pr谩ctico, ya que se pierde la ventaja de las promesas. 
async function getFirstUserData() {
  const response = await fetch('/users.json');
  const users = await response.json();
  const user = users[0];
  const userResponse = await fetch(`/users/${user.name}`);
  const userData = await userResponse.json();
  return userData;
}

//Llamada a la funci贸n
const user_data = await getFirstUserData();

//Se puede refactorizar de la siguiente forma, para mantener la estructura de las promesas, y aprovechar la ventaja de async/await.
async function getFirstUserData() {
  const userData = await fetch('/users.json')
    .then(response => response.json())
    .then(users => users[0])
    .then(user => fetch(`/users/${user.name}`))
    .then(userResponse => userResponse.json());

  return userData;
}

//Para llamar a la funci贸n
const user_data = await getFirstUserData();
```

De esta forma se mantiene la estructura de las promesas, y se aprovecha la ventaja de async/await.
